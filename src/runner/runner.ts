/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {Content, createPartFromText} from '@google/genai';

import {BaseAgent} from '../agents/base_agent.js';
import {InvocationContext, newInvocationContextId} from '../agents/invocation_context.js';
import {LlmAgent} from '../agents/llm_agent.js';
import {RunConfig} from '../agents/run_config.js';
import {BaseArtifactService} from '../artifacts/base_artifact_service.js';
import {BaseCredentialService} from '../auth/credential_service/base_credential_service.js';
import {Event} from '../events/event.js';
import {EventActions} from '../events/event_actions.js';
import {BaseMemoryService} from '../memory/base_memory_service.js';
// Import Plugin Infrastructure
import { BasePlugin } from '../plugins/base_plugin.js';
import { PluginManager } from '../plugins/plugin_manager.js';
import {BaseSessionService} from '../sessions/base_session_service.js';
import {Session} from '../sessions/session.js';

// TODO - b/425992518: Implement BuiltInCodeExecutor
// TODO - b/425992518: Implement tracer

interface RunnerInput {
  appName: string;
  agent: BaseAgent;
  plugins?: BasePlugin[];
  artifactService?: BaseArtifactService;
  sessionService: BaseSessionService;
  memoryService?: BaseMemoryService;
  credentialService?: BaseCredentialService;
}

type ExecutionFn = (ctx: InvocationContext) => AsyncGenerator<Event, void, void>;

export class Runner {
  readonly appName: string;
  readonly agent: BaseAgent;
  readonly artifactService?: BaseArtifactService;
  readonly sessionService: BaseSessionService;
  readonly memoryService?: BaseMemoryService;
  readonly credentialService?: BaseCredentialService;
  readonly pluginManager: PluginManager;

  constructor(input: RunnerInput) {
    this.appName = input.appName;
    this.agent = input.agent;
    this.artifactService = input.artifactService;
    this.sessionService = input.sessionService;
    this.memoryService = input.memoryService;
    this.credentialService = input.credentialService;
    this.pluginManager = new PluginManager(input.plugins);
  }

  /**
   * Runs the agent and returns all generated events.
   *
   * !!NOTE: This synchronous interface is provided for local testing and
   * convenience only. For production use cases, prefer the `runAsync` method
   * which returns an async generator.
   */
  async runSync({
    userId,
    sessionId,
    newMessage,
    runConfig = new RunConfig(),
  }: {
    userId: string; sessionId: string; newMessage: Content;
    runConfig?: RunConfig;
  }): Promise<Event[]> {
    const events: Event[] = [];
    for await (const event of this.runAsync(
        {userId, sessionId, newMessage, runConfig})) {
      events.push(event);
    }
    return events;
  }

  /**
   * Runs the agent with the given message, and returns an async generator of
   * events.
   *
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param newMessage A new message to append to the session.
   * @param stateDelta An optional state delta to apply to the session.
   * @param runConfig The run config for the agent.
   * @yields The events generated by the agent.
   */
  // TODO - b/425992518: user, sessionId, and runConfig can be internalized.
  async * runAsync({
    userId,
    sessionId,
    newMessage,
    stateDelta,
    runConfig = new RunConfig(),
  }: {
    userId: string; sessionId: string; newMessage: Content;
    stateDelta?: Record<string, any>;
    runConfig?: RunConfig;
  }): AsyncGenerator<Event, void, undefined> {
    // TODO - b/425992518: Add telemetry
    // =========================================================================
    // Setup the session and invocation context
    // =========================================================================
    const session =
        await this.sessionService.getSession(this.appName, userId, sessionId);

    if (!session) {
      throw new Error(`Session not found: ${sessionId}`);
    }

    if (runConfig.supportCfc && this.agent instanceof LlmAgent) {
      const modelName = this.agent.canonicalModel.model;
      if (!modelName.startsWith('gemini-2')) {
        throw new Error(`CFC is not supported for model: ${
            modelName} in agent: ${this.agent.name}`);
      }
      // TODO - b/425992518: Add code executor support
    }

        // Use the protected helper method for context creation
    const invocationContext = this.newInvocationContext({
        session,
        newMessage,
        runConfig,
    });

    const modifiedUserMessage = await this.pluginManager.runOnUserMessageCallback({
        invocationContext,
        userMessage: newMessage,
    });

    const finalNewMessage = modifiedUserMessage || newMessage;

    // =========================================================================
    // Append user message to session
    // =========================================================================
    if (finalNewMessage) {
      await this.appendNewMessageToSession(
          session,
          finalNewMessage,
          invocationContext,
          runConfig.saveInputBlobsAsArtifacts,
          stateDelta
      );
    }

    // =========================================================================
    // Determine which agent should handle the workflow resumption.
    // =========================================================================
    invocationContext.agent = this.findAgentToRun(session, this.agent);

    // =========================================================================
    // Run the agent with the plugins (aka hooks to apply in the lifecycle)
    // =========================================================================
    
    // The default execution function simply calls agent.runAsync.
    const executeFn: ExecutionFn = (ctx) => ctx.agent.runAsync(ctx);

    // Use the execWithPlugin helper to wrap the main execution logic (before_run, on_event, after_run).
    for await (const event of this.execWithPlugin(invocationContext, session, executeFn)) {
        yield event;
    }
  }

  /**
   * Protected helper to create a new InvocationContext.
   */
  protected newInvocationContext(params: {
      session: Session,
      newMessage: Content,
      runConfig: RunConfig
  }): InvocationContext {
    return new InvocationContext({
        artifactService: this.artifactService,
        sessionService: this.sessionService,
        memoryService: this.memoryService,
        credentialService: this.credentialService,
        pluginManager: this.pluginManager, 
        invocationId: newInvocationContextId(),
        agent: this.agent,
        session: params.session,
        userContent: params.newMessage,
        runConfig: params.runConfig,
      });
  }

  /**
   * Protected helper to append a new message to the session.
   */
  protected async appendNewMessageToSession(
      session: Session,
      newMessage: Content,
      invocationContext: InvocationContext,
      saveArtifacts: boolean,
      stateDelta?: Record<string, any>
  ): Promise<void> {
    if (!newMessage.parts?.length) {
        throw new Error('No parts in the new_message.');
      }

      if (saveArtifacts) {
        await this.saveArtifacts(
            invocationContext.invocationId, session.userId, session.id,
            newMessage);
      }
      // Append the user message to the session with optional state delta.
      await this.sessionService.appendEvent(
          session, new Event({
            invocationId: invocationContext.invocationId,
            author: 'user',
            actions: stateDelta ? new EventActions({stateDelta}) : undefined,
            content: newMessage,
          }));
  }

  /**
   * Executes the provided function wrapped by the runner-level plugin hooks.
   * (before_run, on_event, after_run).
   */
  protected async *execWithPlugin(
      invocationContext: InvocationContext,
      session: Session,
      executeFn: ExecutionFn
  ): AsyncGenerator<Event, void, void> {

    // Step 1: Run the before_run callbacks to see if we should early exit.
    const earlyExitContent = await this.pluginManager.runBeforeRunCallback({
        invocationContext,
    });

    if (earlyExitContent) {
        // If a plugin returns content, we create an event, save it, and exit immediately.
        const event = new Event({
            invocationId: invocationContext.invocationId,
            author: this.appName, // Authored by the runner/system
            content: earlyExitContent,
        });
        
        // Run on_event for this early exit event too
        const modifiedEvent = await this.pluginManager.runOnEventCallback({
            invocationContext,
            event,
        });

        const finalEvent = modifiedEvent || event;

        if (!finalEvent.partial) {
            await this.sessionService.appendEvent(session, finalEvent);
        }
        yield finalEvent;

        // Proceed to after_run callback even on early exit.
        await this.pluginManager.runAfterRunCallback({ invocationContext });
        return;
    }

    // Step 2: Otherwise continue with normal execution
    for await (const event of executeFn(invocationContext)) {
      
      // Step 3: Run the on_event callbacks to optionally modify the event.
      const modifiedEvent = await this.pluginManager.runOnEventCallback({
          invocationContext,
          event,
      });

      const finalEvent = modifiedEvent || event;

      // Persist the event (using the potentially modified version)
      if (!finalEvent.partial) {
        await this.sessionService.appendEvent(session, finalEvent);
      }
      
      yield finalEvent;
    }

    // Step 4: Run the after_run callbacks.
    await this.pluginManager.runAfterRunCallback({ invocationContext });
  }

  /**
   * Saves artifacts from the message parts and replaces the inline data with
   * a file name placeholder.
   *
   * @param invocationId The current invocation ID.
   * @param userId The user ID of the session.
   * @param sessionId The session ID of the session.
   * @param message The message containing parts to process.
   */
  private async saveArtifacts(
      invocationId: string, userId: string, sessionId: string,
      message: Content): Promise<void> {
    if (!this.artifactService || !message.parts?.length) {
      return;
    }

    for (let i = 0; i < message.parts.length; i++) {
      const part = message.parts[i];
      if (!part.inlineData) {
        continue;
      }
      const fileName = `artifact_${invocationId}_${i}`;
      // TODO - b/425992518: group appname, userId, sessionId as a key.
      await this.artifactService.saveArtifact(
          this.appName, userId, sessionId, fileName, part);
      // TODO - b/425992518: potentially buggy if accidentally exposed to LLM.
      message.parts[i] = createPartFromText(
          `Uploaded file: ${fileName}. It is saved into artifacts`);
    }
  }

   /**
   * Determines the next agent to run to continue the session. 
   * Public facing protected method for subclasses.
   */
  protected findAgentToRun(session: Session, rootAgent: BaseAgent): BaseAgent {
    return this.determineAgentForResumption(session, rootAgent);
  }

  /**
   * Determines the next agent to run to continue the session. This is primarily
   * used for session resumption.
   */
  // TODO - b/425992518: This is where LRO integration should happen.
  // Needs clean up before we can generalize it.
  private determineAgentForResumption(session: Session, rootAgent: BaseAgent):
      BaseAgent {
    // =========================================================================
    // Case 1: If the last event is a function response, this returns the
    // agent that made the original function call.
    // =========================================================================
    const event = findEventByLastFunctionResponseId(session.events);
    if (event && event.author) {
      return rootAgent.findAgent(event.author) || rootAgent;
    }

    // =========================================================================
    // Case 2: Otherwise, find the last agent that emitted a message and is
    // transferable across the agent tree.
    // =========================================================================
    // TODO - b/425992518: Optimize this, not going to work for long sessions.
    // TODO - b/425992518: The behavior is dynamic, needs better documentation.
    for (let i = session.events.length - 1; i >= 0; i--) {
      const event = session.events[i];
      if (event.author === 'user' || !event.author) {
        continue;
      }

      if (event.author === rootAgent.name) {
        return rootAgent;
      }

      const agent = rootAgent.findSubAgent(event.author!);
      if (!agent) {
        console.warn(`Event from an unknown agent: ${event.author}, event id: ${
            event.id}`);
        continue;
      }
      if (this.isRoutableLlmAgent(agent)) {
        return agent;
      }
    }
    // =========================================================================
    // Case 3: default to root agent.
    // =========================================================================
    return rootAgent;
  }

  /**
   * Whether the agent to run can transfer to any other agent in the agent tree.
   *
   * An agent is transferable if:
   *  - It is an instance of `LlmAgent`.
   *  - All its ancestors are also transferable (i.e., they have
   *    `disallowTransferToParent` set to false).
   *
   * @param agentToRun The agent to check for transferability.
   * @returns True if the agent can transfer, False otherwise.
   */
  private isRoutableLlmAgent(agentToRun: BaseAgent): boolean {
    let agent: BaseAgent|undefined = agentToRun;
    while (agent) {
      if (!(agent instanceof LlmAgent)) {
        return false;
      }
      if (agent.disallowTransferToParent) {
        return false;
      }
      agent = agent.parentAgent;
    }
    return true;
  }
  // TODO - b/425992518: Implement runLive and related methods.
}

/**
 * It iterates through the events in reverse order, and returns the event
 * containing a function call with a functionCall.id matching the
 * functionResponse.id from the last event in the session.
 */
// TODO - b/425992518: a hack that used event log as transaction log. Fix.
function findEventByLastFunctionResponseId(events: Event[]): Event|null {
  if (!events.length) {
    return null;
  }

  const lastEvent = events[events.length - 1];
  const functionCallId =
      lastEvent.content?.parts?.find((part) => part.functionResponse)
          ?.functionResponse?.id;
  if (!functionCallId) {
    return null;
  }

  // TODO - b/425992518: inefficient search, fix.
  for (let i = events.length - 2; i >= 0; i--) {
    const event = events[i];
    // Looking for the system long running request euc function call.
    const functionCalls = event.getFunctionCalls();
    if (!functionCalls) {
      continue;
    }

    for (const functionCall of functionCalls) {
      if (functionCall.id === functionCallId) {
        return event;
      }
    }
  }
  return null;
}
