/**
 * @license
 * Copyright 2025 Google LLC
 * SPDX-License-Identifier: Apache-2.0
 */

import {Content} from '@google/genai';
import {trace} from '@opentelemetry/api';

import {createEvent, Event} from '../events/event.js';

import {CallbackContext} from './callback_context.js';
import {InvocationContext} from './invocation_context.js';

type SingleAgentCallback = (context: CallbackContext) =>
    Promise<Content|undefined>|(Content|undefined);

type BeforeAgentCallback = SingleAgentCallback|SingleAgentCallback[];

type AfterAgentCallback = SingleAgentCallback|SingleAgentCallback[];

/**
 * The config of a base agent.
 */
export interface BaseAgentConfig {
  name: string;
  description?: string;
  parentAgent?: BaseAgent;
  subAgents?: BaseAgent[];
  beforeAgentCallback?: BeforeAgentCallback;
  afterAgentCallback?: AfterAgentCallback;
}

/**
 * Base class for all agents in Agent Development Kit.
 */
export abstract class BaseAgent {
  /**
   * The agent's name.
   * Agent name must be a JS identifier and unique within the agent tree.
   * Agent name cannot be "user", since it's reserved for end-user's input.
   */
  readonly name: string;

  /**
   * Description about the agent's capability.
   *
   * The model uses this to determine whether to delegate control to the agent.
   * One-line description is enough and preferred.
   */
  readonly description?: string;

  /**
   * Root agent of this agent.
   */
  readonly rootAgent: BaseAgent;

  /**
   * The parent agent of this agent.
   *
   * Note that an agent can ONLY be added as sub-agent once.
   *
   * If you want to add one agent twice as sub-agent, consider to create two
   * agent instances with identical config, but with different name and add them
   * to the agent tree.
   *
   * The parent agent is the agent that created this agent.
   */
  parentAgent?: BaseAgent;

  /**
   * The sub-agents of this agent.
   */
  readonly subAgents: BaseAgent[];

  /**
   * Callback or list of callbacks to be invoked before the agent run.
   *
   * When a list of callbacks is provided, the callbacks will be called in the
   * order they are listed until a callback does not return undefined.
   *
   * @param callbackContext: MUST be named 'callbackContext' (enforced).
   *
   * @return Content: The content to return to the user. When the content is
   *     present, the agent run will be skipped and the provided content will be
   *     returned to user.
   */
  readonly beforeAgentCallback: SingleAgentCallback[];

  /**
   * Callback or list of callbacks to be invoked after the agent run.
   *
   * When a list of callbacks is provided, the callbacks will be called in the
   * order they are listed until a callback does not return undefined.
   *
   * @param callbackContext: MUST be named 'callbackContext' (enforced).
   *
   * @return Content: The content to return to the user. When the content is
   *     present, the provided content will be used as agent response and
   *     appended to event history as agent response.
   */
  readonly afterAgentCallback: SingleAgentCallback[];

  constructor(config: BaseAgentConfig) {
    this.name = validateAgentName(config.name);
    this.description = config.description;
    this.parentAgent = config.parentAgent;
    this.subAgents = config.subAgents || [];
    this.rootAgent = getRootAgent(this);
    this.beforeAgentCallback =
        getCannonicalCallback(config.beforeAgentCallback);
    this.afterAgentCallback = getCannonicalCallback(config.afterAgentCallback);

    this.setParentAgentForSubAgents();
  }

  /**
   * Entry method to run an agent via text-based conversation.
   *
   * @param parentContext The invocation context of the parent agent.
   * @yields The events generated by the agent.
   * @returns An AsyncGenerator that yields the events generated by the agent.
   */
  async *
      run(parentContext: InvocationContext): AsyncGenerator<Event, void, void> {
    const span = trace.getTracer('gcp.vertex.agent')
                     .startSpan(`agent_run [${this.name}]`);
    try {
      const context = this.createInvocationContext(parentContext);

      const beforeAgentCallbackEvent =
          await this.handleBeforeAgentCallback(context);
      if (beforeAgentCallbackEvent) {
        yield beforeAgentCallbackEvent;
      }

      if (context.endInvocation) {
        return;
      }

      for await (const event of this.runImpl(context)) {
        yield event;
      }

      if (context.endInvocation) {
        return;
      }

      const afterAgentCallbackEvent =
          await this.handleAfterAgentCallback(context);
      if (afterAgentCallbackEvent) {
        yield afterAgentCallbackEvent;
      }
    } finally {
      span.end();
    }
  }

  /**
   * Entry method to run an agent via video/audio-based conversation.
   *
   * @param parentContext The invocation context of the parent agent.
   * @yields The events generated by the agent.
   * @returns An AsyncGenerator that yields the events generated by the agent.
   */
  async *
      runLive(parentContext: InvocationContext):
          AsyncGenerator<Event, void, void> {
    const span = trace.getTracer('gcp.vertex.agent')
                     .startSpan(`agent_run [${this.name}]`);
    try {
      // TODO(b/425992518): Implement live mode.
      throw new Error('Live mode is not implemented yet.');
    } finally {
      span.end();
    }
  }

  /**
   * Core logic to run this agent via text-based conversation.
   *
   * @param context The invocation context of the agent.
   * @yields The events generated by the agent.
   * @returns An AsyncGenerator that yields the events generated by the agent.
   */
  protected abstract runImpl(context: InvocationContext):
      AsyncGenerator<Event, void, void>;

  /**
   * Core logic to run this agent via video/audio-based conversation.
   *
   * @param context The invocation context of the agent.
   * @yields The events generated by the agent.
   * @returns An AsyncGenerator that yields the events generated by the agent.
   */
  protected abstract runLiveImpl(context: InvocationContext):
      AsyncGenerator<Event, void, void>;

  /**
   * Finds the agent with the given name in this agent and its descendants.
   *
   * @param name The name of the agent to find.
   * @return The agent with the given name, or undefined if not found.
   */
  findAgent(name: string): BaseAgent|undefined {
    if (this.name === name) {
      return this;
    }

    return this.findSubAgent(name);
  }

  /**
   * Finds the agent with the given name in this agent's descendants.
   *
   * @param name The name of the agent to find.
   * @return The agent with the given name, or undefined if not found.
   */
  findSubAgent(name: string): BaseAgent|undefined {
    for (const subAgent of this.subAgents) {
      const result = subAgent.findAgent(name);
      if (result) {
        return result;
      }
    }

    return undefined;
  }

  /**
   * Creates an invocation context for this agent.
   *
   * @param parentContext The invocation context of the parent agent.
   * @return The invocation context for this agent.
   */
  protected createInvocationContext(parentContext: InvocationContext):
      InvocationContext {
    return new InvocationContext({
      ...parentContext,
      agent: this,
    });
  }

  /**
   * Runs the before agent callback if it exists.
   *
   * @param invocationContext The invocation context of the agent.
   * @return The event to return to the user, or undefined if no event is
   *     generated.
   */
  protected async handleBeforeAgentCallback(
      invocationContext: InvocationContext): Promise<Event|undefined> {
    if (this.beforeAgentCallback.length === 0) {
      return undefined;
    }

    const callbackContext = new CallbackContext({invocationContext});
    for (const callback of this.beforeAgentCallback) {
      const content = await callback(callbackContext);

      if (content) {
        invocationContext.endInvocation = true;

        return createEvent({
          invocationId: invocationContext.invocationId,
          author: this.name,
          branch: invocationContext.branch,
          content,
          actions: callbackContext.eventActions,
        });
      }
    }

    if (callbackContext.state.hasDelta()) {
      return createEvent({
        invocationId: invocationContext.invocationId,
        author: this.name,
        branch: invocationContext.branch,
        actions: callbackContext.eventActions,
      });
    }

    return undefined;
  }

  /**
   * Runs the after agent callback if it exists.
   *
   * @param invocationContext The invocation context of the agent.
   * @return The event to return to the user, or undefined if no event is
   *     generated.
   */
  protected async handleAfterAgentCallback(
      invocationContext: InvocationContext): Promise<Event|undefined> {
    if (this.afterAgentCallback.length === 0) {
      return undefined;
    }

    const callbackContext = new CallbackContext({invocationContext});
    for (const callback of this.afterAgentCallback) {
      const content = await callback(callbackContext);

      if (content) {
        return createEvent({
          invocationId: invocationContext.invocationId,
          author: this.name,
          branch: invocationContext.branch,
          content,
          actions: callbackContext.eventActions,
        });
      }
    }

    if (callbackContext.state.hasDelta()) {
      return createEvent({
        invocationId: invocationContext.invocationId,
        author: this.name,
        branch: invocationContext.branch,
        actions: callbackContext.eventActions,
      });
    }

    return undefined;
  }

  private setParentAgentForSubAgents(): void {
    for (const subAgent of this.subAgents) {
      if (subAgent.parentAgent) {
        throw new Error(`Agent "${
            subAgent.name}" already has a parent agent, current parent: "${
            subAgent.parentAgent.name}", trying to add: "${this.name}"`);
      }

      subAgent.parentAgent = this;
    }
  }
}

/**
 * Validates the agent name.
 *
 * @param name The name of the agent.
 * @return The validated agent name.
 */
function validateAgentName(name: string): string {
  if (!isIdentifier(name)) {
    throw new Error(`Found invalid agent name: "${
        name}". Agent name must be a valid identifier. It should start with a letter (a-z, A-Z) or an underscore (_), and can only contain letters, digits (0-9), and underscores.`);
  }

  if (name === 'user') {
    throw new Error(
        `Agent name cannot be 'user'. 'user' is reserved for end-user's input.`);
  }

  return name;
}

/**
 * Checks if the given string is a valid identifier.
 *
 * @param str The string to check.
 * @return True if the string is a valid identifier, false otherwise.
 */
function isIdentifier(str: string): boolean {
  return /^[\p{ID_Start}$_][\p{ID_Continue}$_]*$/u.test(str);
}

/**
 * Gets the root agent of the given agent.
 *
 * @param rootAgent The root agent to get the root agent of.
 * @return The root agent.
 */
function getRootAgent(rootAgent: BaseAgent): BaseAgent {
  while (rootAgent.parentAgent) {
    rootAgent = rootAgent.parentAgent;
  }

  return rootAgent;
}

/**
 * Gets the canonical callback from the given callback.
 *
 * @param callbacks The callback or list of callbacks to get the canonical
 *     callback from.
 * @return The canonical callback.
 */
export function getCannonicalCallback<T>(callbacks?: T|T[]): T[] {
  if (!callbacks) {
    return [];
  }

  return Array.isArray(callbacks) ? callbacks : [callbacks];
}